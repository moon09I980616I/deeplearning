# ****Softmax Regression****

# 원-핫 인코딩(One-Hot Encoding)

선택해야 하는 선택지의 개수만큼의 차원을 가지면서, 각 선택지의 인덱스에 해당하는 원소에는 1, 나머지 원소는 0의 값을 가지도록 하는 표현 방법

강아지 = [1,0,0]

고양이 = [0,1,0]

냉장고 = [0,0,1]

원-핫 벡터는 이처럼 각 클래스의 표현 방법이 무작위성을 가짐

관계의 무작위성은 때로는 단어의 유사성을 구할 수 없다는 단점으로 언급됨

# ****소프트맥스 회귀(Softmax Regression)****

소프트맥스 회귀를 통한 다중 클래스 분류

## ****1. 다중 클래스 분류(Multi-class Classification)****

세 개 이상의 답 중 하나를 고르는 문제를 다중 클래스 분류라고 한다.

### 1. ****1. 로지스틱 회귀****

로지스틱 회귀에서 시그모이드 함수는 예측값을 0과 1 사이의 값으로 만든다. 예를 들어 스팸 메일 분류기를 로지스틱 회귀로 구현하였을 때 출력이 0.75라면 이는 이메일이 스팸일 확률이 75%라는 의미와 스팸 메일이 아닐 확률은 25%가 되고 이 두 확률의 총 합은 1이다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/5cdefbac-24e7-4688-8f23-62281403ba49)


### 1. ****2. 소프트맥스 회귀****

소프트맥스 회귀는 확률의 총 합이 1이 되는 이 아이디어를 다중 클래스 분류 문제에 적용한다. 소프트맥스 회귀는 각 클래스. 즉 각 선택지마다 소수 확률을 할당한다. 이 때 총 확률의 합은 1이 되어야 한다. 이렇게 되면 각 선택지가 정답일 확률로 표현된다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/5d4dcde2-e516-4eb9-848d-73f188c1781f)

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/3ab7589c-8b95-4d08-bc89-d4d06d7027a4)


## 2. 소프트맥스 함수(Softmax function)

소프트맥스 함수는 분류해야하는 정답지(클래스)의 총 개수를 k라고 할 때, k차원의 벡터를 입력받아 각 클래스에 대한 확률을 추정

k차원의 벡터에서 i번째 원소를 $\mathrm{z_i}$, i번째 클래스가 정답일 확률을 $\mathrm{p_i}$로 나타낸다고 하였을 때 소프트맥스 함수는 $p_i$를 다음과 같이 정의한다.

$$
p_i=\frac{e^{z_i}}{{\sum_{j=1}^{k} {e^zj}}} = for i = 1,2,...k
$$

위에서 풀어야하는 문제에 소프트맥수 함수를 적용해보면 위에서 풀어야하는 문제의 경우 k=3이므로 3차원 벡터 $z=[z_1z_2z_3]$의 입력을 받으면 소프트맥수 함수는 아래와 같은 출력을 리턴한다.

$$
softmax(z)=\frac{e^{z_1}}{{\sum_{j=1}^{3} {e^{zj}}}}\frac{e^{z_2}}{{\sum_{j=1}^{3} {e^{zj}}}}\frac{e^{z_3}}{{\sum_{j=1}^{3} {e^{zj}}}} = [p_1,p_2,p_3] =y=예측값
$$

$p1,p2,p3$ 각각은 1번 클래스가 정답일 확률, 2번 클래스가 정답일 확률, 3번 클래스가 정답일 확률을 나타내며 각각 0과 1 사이의 값으로 총 합은 1이 된다. 여기서 분류하고자하는 3개의 클래스는 virginica, setosa, versicolor이므로 이는 결국 주어진 입력이 virginica일 확률, setosa일 확률, versicolor일 확률을 나타내는 값을 의미한다. 여기서는 i가 1일 때는 virginica일 확률을 나타내고, 2일 때는 setosa일 확률, 3일 때는 versicolor일 확률이라고 지정했다고 하면 이 지정 순서는 문제를 풀고자 하는 사람의 무작위 선택이다. 이에 따라 식을 문제에 맞게 다시 쓰면 아래와 같다.

$$
softmax(z)=\frac{e^{z_1}}{{\sum_{j=1}^{3} {e^{zj}}}}\frac{e^{z_2}}{{\sum_{j=1}^{3} {e^{zj}}}}\frac{e^{z_3}}{{\sum_{j=1}^{3} {e^{zj}}}} = [p_1,p_2,p_3] =[p_{virginica},p_{setosa},p_{versicolor}] 
$$

분류하고자 하는 클래스가 k개일 때, k차원의 벡터를 입력 받아서 모든 벡터 원소의 값을 0과 1사이로 값을 변경하여 다시 k차원의 벡터를 리턴한다는 내용의 식

⇒ 분류하고자 하는 클래스 k개

→ k차원의 벡터를 입력 받은 뒤 모든 벡터 값을 0과 1사이로 변경

→ 다시 k차원의 벡터를 리턴

### 그림을 통한 이해

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/b481d1a6-0ac2-4925-b30a-4af75fd5ee72)


샘플 데이터를 1개씩 입력으로 받아서 처리한다고 가정한다. 즉 배치 크기가 1이다.

위의 그림에는 두 가지 질문이 있다. 첫번째 질문은 소프트맥스 함수의 입력에 대한 질문이다. 하나의 샘플 데이터는 4개의 독립 변수 x를 가지는데 이는 모델이 4차원 벡터를 입력으로 받음을 의미한다. 그런데 소프트맥스의 함수의 입력으로 사용되는 벡터는 벡터의 차원이 분류하고자 하는 클래스의 개수가 되어야 하므로 어떤 가중치 연산을 통해 3차원 벡터로 변환되어야 한다. 위의 그림에서는 소프트맥스 함수의 입력으로 사용되는 3차원 벡터를 z로 표현했다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/86b51fb4-9f48-4fcb-b270-1aca2c15fc8e)


샘플 데이터 벡터를 소프트맥스 함수의 입력 벡터로 차원을 축소하는 방법은 간단하다. 소프트맥스 함수의 입력 벡터 z의 차원수만큼 결과값이 나오도록 가중치 곱을 진행한다. 위의 그림에서 화살표는 총 (4x3=12) 12개이며 전부 다른 가중치를 가지고 학습 과정에서 점차적으로 오차를 최소화하는 가중치로 값이 변경된다.

두번째 질문은 오차 계산 방법에 대한 질문이다. 소프트맥스 함수의 출력은 분류하고자하는 클래스의 개수만큼 차원을 가지는 벡터로 각 원소는 0과 1 사이의 값을 가진다. 이 각각은 특정 클래스가 정답일 확률을 나타낸다. 여기서는 첫번째 원소인 $p_1$은 virginica가 정답일 확률, 두번째 원소인 $p_2$는 setosa가 정답일 확률, 세번째 원소인 $p_3$은 versicolor가 정답일 확률로 고려하고자 한다. 그렇다면 이 예측값과 비교를 할 수 있는 실제값의 표현 방법이 있어야 한다. 소프트맥스 회귀에서는 실제값을 원-핫 벡터로 표현한다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/839ded44-e41e-4f5a-bae6-d5a7b21020e9)


위의 그림은 소프트맥스 함수의 출력 벡터의 첫번째 원소 $p_1$가 virginica가 정답일 확률, 두번째 원소 $p_2$가 setosa가 정답일 확률, 세번째 원소 $p_3$가 versicolor가 정답일 확률을 의미한다고 하였을 때, 각 실제값의 정수 인코딩은 1, 2, 3이 되고 이에 원-핫 인코딩을 수행하여 실제값을 원-핫 벡터로 수치화한 것을 보여준다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/1543b732-07ec-4a3f-8165-334318edf4c6)


예를 들어 현재 풀고 있는 샘플 데이터의 실제값이 setosa라면 setosa의 원-핫 벡터는 [0 1 0]이다.

이 경우, 예측값과 실제값의 오차가 0이 되는 경우는 소프트맥스 함수의 결과가 [0 1 0]이 되는 경우로 이 두 벡터의 오차를 계산하기 위해서 소프트맥스 회귀는 비용 함수로 **크로스 엔트로피 함수**를 사용한다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/e9a6fb42-5628-4f9d-94de-f9114cb40b7b)


이제 선형 회귀나 로지스틱 회귀와 마찬가지로 오차로부터 가중치를 업데이트한다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/8894b647-c3c0-4a58-a067-e1c05f6c11de)


더 정확히는 선형 회귀나 로지스틱 회귀와 마찬가지로 편향 또한 업데이트의 대상이 되는 매개변수이다. 소프트맥스 회귀를 벡터와 행렬 연산으로 이해해보면 입력을 특성(feature)의 수만큼의 차원을 가진 입력 벡터 x라고 하고, 가중치 행렬을 $W$, 편향을 $b$라고 하였을 때, 소프트맥스 회귀에서 예측값을 구하는 과정을 벡터와 행렬 연산으로 표현하면 아래와 같다.

![image](https://github.com/moon09I980616I/deeplearning/assets/95466895/1844ade7-05f5-4b8a-94c4-e19c38f6b9c7)


여기서 $f$는 특성의 수이며 $c$는 클래스의 개수에 해당한다.
